import helpers, setup, mitmProxyController, time
from _thread import start_new_thread

##################### GLOBALS ############################


preProcBatch = setup.preProcessingCmds.copy()
postProcBatch = setup.postProcessingCmds.copy()
afterExecBatch = setup.afterExecCmds.copy()


logger = None
#config = setup.config

##################### Pre- and Postprocessing routines ############################
# Control Flow:
#
# If "execWithExternalCallback" : True,
#   then: 1. -> (2.) -> 3.
# else,
#   then: 1. -> 2. -> 3
#
# use sProcessor.args dict to transfer data between these functions:
#
#############

#1.
def preProcessingRoutine(sProcessor):
    helpers.psexecCmdBatch(sProcessor.sandbox, preProcBatch)

    runtime = sProcessor.runtime
    logger.info("[+] Run proxy for " + str(runtime) + " seconds")

    sampleLogDir = helpers.createSampleLogDir(sProcessor)
    sProcessor.args["sampleLogDir"] = sampleLogDir

    if sProcessor.enableMitmProxy:
        mitmProxyController.startProxyAndExec(runtime, sProcessor, sampleLogDir, sProcessor.enableCnCsimulation) #returns after runtime seconds ...cant run startProxy() in new thread, so runtime of the proxy is equal to sample runtime

#2. (if mitmProxy enabled, then it will be called when mitmProxy starts running)
def executeRoutine(sProcessor):
    helpers.executionBatchTuple.clear()

    remoteCmdStr = sProcessor.sandbox.remoteSamplePath
    helpers.addExecToBatch('cmd /c psexec -i -d ' + remoteCmdStr + " 1^^^> pslog.txt 2^^^>^^^&1", sProcessor.sandbox.runExecFromDir)#escaped: 1^> pslog.txt 2^>^&1 #escaped: 1> pslog.txt 2>&1

    helpers.addCmdToBatch("timeout 1") #needed, need delay between sample execution and WindowInteraction


    sProcessor.args["samplePid"] = "000"# not needed

    for command in afterExecBatch:
        helpers.addExecToBatch(command, "C:\logs")

    helpers.createBatchFile(sProcessor.sandbox)
    helpers.psexec(sProcessor.sandbox, "C:\startExec.bat", sProcessor.sandbox.runExecFromDir, "-h")


#3. (will be called after the defined runtime elapsed)
def postProcessingRoutine(sProcessor):
    helpers.execBatch(sProcessor.sandbox, postProcBatch)

    logger.info("[+] Fetch files ...")

    sampleLogDir = sProcessor.args["sampleLogDir"]
    helpers.downloadLogs(sProcessor, sampleLogDir)

    samplePid = sProcessor.args["samplePid"] # not needed
    sProcessor.args["samplePid"] = 0 #clear

    pidFile = open(sampleLogDir + "samplePid.txt", "w")
    pidFile.write(str(samplePid))
    pidFile.close()

########################################################################################

#Change configuration

def removeWalletProtection():
    global preProcBatch, postProcBatch
    preProcBatch[2] = ""
    preProcBatch[3] = ""
    preProcBatch[4] = ""
    preProcBatch.remove("")
    preProcBatch.remove("")
    preProcBatch.remove("")


    postProcBatch[2] = ""
    postProcBatch[3] = ""
    postProcBatch.remove("")
    postProcBatch.remove("")

def removeWindowInteraction():
    global afterExecBatch
    afterExecBatch[0] = ""
    afterExecBatch.remove("")

def restoreBatches():
    global preProcBatch, postProcBatch, afterExecBatch
    preProcBatch = setup.preProcessingCmds
    postProcBatch = setup.postProcessingCmds
    afterExecBatch = setup.afterExecCmds