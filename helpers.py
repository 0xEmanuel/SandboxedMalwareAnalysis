import utils, setup,os, sandboxLib, traceback,time
from enum import Enum


executionBatchTuple = []

class HttpPacketType(Enum):
    Request = 1
    Response = 2

def psexecCmdBatch(sandbox, commands):
    for command in commands:
        psexec(sandbox, command, "C:\\logs", "-h")

def execBatch(sandbox, commands):
    for command in commands:
        sandbox.execute(command)

def createSampleLogDir(sProcessor):
    downloadLocalDirAfterProcessing = sProcessor.downloadLocalDirAfterProcessing

    parentDirPath = os.path.dirname(sProcessor.currentSampleLocalFilePath)
    parentDirName = os.path.basename(parentDirPath)
    filename = utils.extractFileNameFromFilePath(sProcessor.currentSampleLocalFilePath)

    localDirPath = downloadLocalDirAfterProcessing + parentDirName + "/" + filename + "_" + utils.createTimestamp() + "/"
    return localDirPath

def downloadLogs(sProcessor, localDirPath):
    downloadRemoteDirAfterProcessing = sProcessor.downloadRemoteDirAfterProcessing
    sProcessor.sandbox.sftpClient.downloadDir(downloadRemoteDirAfterProcessing, localDirPath)


def psexec(sandbox, cmdStr, workingDir, flags):
    if workingDir.endswith('/'):
        workingDir = workingDir[:-1]

    psexecCmd = "C:/Windows/IME/en-US/PSExec  \\\\127.0.0.1 -u " + sandbox.sshClient.user + " -p " + sandbox.sshClient.password +  " -w " + workingDir + " -i -d " # -h for evalated token


    psexecCmd += flags + " "

    stdoutText = ""
    stderrText = ""
    pid = "0"
    tryCounter = 0
    while tryCounter <= 3:
        stdoutText, stderrText = sandbox.execute(psexecCmd + cmdStr)  # execute "locally" on remote host

        if (stderrText.find("Error communicating with PsExec service") != -1):
            tryCounter +=1
            sandboxLib.logger.warning("PsExec failed... tryCounter: " + str(tryCounter))
        elif (stderrText.find("Error establishing communication with PsExec service") != -1):
            tryCounter += 1

        elif (stderrText.find("PsExec could not start") != -1):
            sandboxLib.logger.warning("Execution not possible. Is it an Exe/PE file?")
            return "-1"
        else: #successful
            break

    if(tryCounter > 3):
        sandboxLib.logger.error("PsExec still failing after " + str(tryCounter) + " tries!")
    else: #successful
        pid = stderrText.split("process ID", 1)[1]
        pid = pid[1:-2]  # skip first and last character

    return pid

def addExecToBatch(cmd, workingDir):
    workingDir = workingDir.replace("/", "\\")
    executionBatchTuple.append("start /D " + workingDir + " "+ cmd)

def addCmdToBatch(cmd):
    executionBatchTuple.append(cmd)

def createBatchFile(sandbox):
    sandbox.execute('$null >> C:\startExec.bat')
    for cmd in executionBatchTuple:
        sandbox.execute('echo ' + cmd +' >> C:\startExec.bat') # via "start" you run the program async in new thread


def saveHttpInfos(dirPath, headersFormattedStr, flow, packetCounter, typeOfPacket):
    filenameHeadersFormatted = ""
    filenameBody = ""
    rawContent = ""

    if(typeOfPacket == HttpPacketType.Request):
        filenameBody = str(packetCounter) + "_" + str(flow.id) + "_RequestBody_" + str(flow.request.pretty_host) + ".txt"
        filenameHeadersFormatted = str(packetCounter) + "_" + str(flow.id) + "_RequestHeadersFormatted_" + str(flow.request.pretty_host) + ".txt"
        rawContent = flow.request.raw_content

    if(typeOfPacket == HttpPacketType.Response):
        filenameBody = str(packetCounter) + "_" + str(flow.id) + "_ResponseBody_" + str(flow.request.pretty_host) + ".txt"
        filenameHeadersFormatted = str(packetCounter) + "_" + str(flow.id) + "_ResponseHeadersFormatted_" + str(flow.request.pretty_host) + ".txt"
        rawContent = flow.response.raw_content

    # save header
    utils.saveToFile(headersFormattedStr, dirPath + filenameHeadersFormatted, "w")

    # save body to file
    utils.saveToFile(rawContent, dirPath + filenameBody, "wb")


def XOR(cipherBytes, keyBtes):
    plainByteArray = []

    for i in range(0, len(cipherBytes)):
        plainByte = cipherBytes[i] ^ keyBtes[i % len(keyBtes)]
        plainByteArray.append(plainByte)

    plaintext = bytes(plainByteArray)

    return plaintext

