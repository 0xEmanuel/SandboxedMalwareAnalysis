import os, paramiko,time, logging, traceback
from subprocess import Popen, PIPE, STDOUT
import utils
from stat import S_ISDIR


EXECUTE_SAMPLES = True


ENABLE_SKIP_UNTIL_SAMPLEPATH = False
START_WITH_SAMPLEPATH = "/home/user/SAMPLE_SETS_PREPARED/EVALSET/prep_AZORult_3_2/a8780f0ca5ec1f27b747c9e2db369bd689ec7d4070e5cc72e96d1449f13ed861"


logger = None
def setGlobalLogger(config):
    global logger
    logger = utils.LoggerFactory(config["loggerName"],config["logDirPath"])
    logger.setLevel(logging.DEBUG)

def SandboxFactory(config):
    vm = VirtualMachine(config)
    sshc = SSHClient(config)
    sftpc = SFTPClient(sshc)
    sb = Sandbox(vm, sshc, sftpc, config)
    return sb

class SampleProcessor:
    def __init__(self, preProcRoutine, postProcRoutine, execRoutine, config):
        self.sandbox = SandboxFactory(config)
        self.readyForExec = False
        self.preProcRoutine = preProcRoutine
        self.postProcRoutine = postProcRoutine
        self.execRoutine = execRoutine
        self.execWithExternalCallback = config["execWithExternalCallback"]
        self.downloadLocalDirAfterProcessing = config["downloadLocalDirAfterProcessing"]
        self.downloadRemoteDirAfterProcessing = config["downloadRemoteDirAfterProcessing"]
        self.runtime = config["runtime"]
        self.enableCnCsimulation = config["enableCnCsimulation"]
        self.enableMitmProxy = config["enableMitmProxy"]
        self.args = {}

    def preProcessing(self):
        self.preProcRoutine(self)

    def postProcessing(self):
        self.postProcRoutine(self)

    def runSampleProcessing(self,localSampleDirPath):

        filenames = sorted(os.listdir(localSampleDirPath))
        logger.info("[-] SubDirs: \n" + str(filenames))

        for filename in filenames:  # filenames of samples
            if os.path.isdir(localSampleDirPath + filename):
                logger.info("[+] Enter local directory: " + localSampleDirPath + filename)
                self.runSampleProcessing(localSampleDirPath + filename + "/")
            elif os.path.isfile(localSampleDirPath + filename):

                global ENABLE_SKIP_UNTIL_SAMPLEPATH
                if ENABLE_SKIP_UNTIL_SAMPLEPATH and (localSampleDirPath + filename) != START_WITH_SAMPLEPATH:
                    logger.info("[-] Skip sample: " + localSampleDirPath + filename)
                    continue #skip sample
                else:
                    ENABLE_SKIP_UNTIL_SAMPLEPATH = False #start processing


                tryCounter = 0
                while tryCounter <= 3:
                    try:
                        logger.info("[+] Start sample processing for: " + localSampleDirPath + filename)
                        self.singleSampleProcessing(localSampleDirPath + filename)
                        break
                    except Exception as e:
                        tryCounter += 1
                        logger.error("Exception: \n" + traceback.format_exc() + "\ntryCounter: " + str(tryCounter))
                        self.sandbox.stop()
            else:
                logger.error("bad file: " + localSampleDirPath + filename)




    def singleSampleProcessing(self, localFilePath):
        self.sandbox.start()
        self.currentSampleLocalFilePath = localFilePath
        self.sandbox.upload(localFilePath)

        logger.info("[+] Preprocessing ...")
        self.preProcessing()

        if not self.execWithExternalCallback:
            self.runExecutable(self.execRoutine) # if not called here, then it should be called somewhere else. i.e. via preProcessing()

        logger.info("[+] Postprocessing ...")
        self.postProcessing()

        logger.info("[+] Stop sandbox ...")
        self.sandbox.stop()

    def runExecutable(self, execRoutine):
        if EXECUTE_SAMPLES:
            logger.info("[+] Execute sample ...")
            execRoutine(self)


class Sandbox:
    def __init__(self, virtualMachine, sshClient, sftpClient, config):
        self.virtualMachine = virtualMachine
        self.sshClient = sshClient
        self.sftpClient = sftpClient
        self.runExecFromDir = config["runExecFromDir"]
        self.newSampleFileName = config["newSampleFileName"]
        self.remoteSamplePath = self.runExecFromDir + self.newSampleFileName

    def start(self):
        self.virtualMachine.startvm()
        counter = 0

        while counter < 3:
            try:
                logger.info("[+] Establish SSH connection ...")
                self.sshClient.establishConnection()
                self.sshClient.execute("whoami")
                self.sftpClient.establishSFTP()

                logger.info("[-] Sandbox is ready!")
                break
            except Exception as e:
                counter = counter + 1
                logger.warning("[-] Failed: " + str(e) + ". counter: " + str(counter) + " retry ...")
                time.sleep(5) # wait before retry

    def upload(self, localFilePath):
        self.sftpClient.uploadFile(localFilePath, self.remoteSamplePath)

    def execute(self, cmdStr):
        stdoutText, stderrText = self.sshClient.execute(cmdStr)
        return stdoutText, stderrText

    def stop(self):
        self.sftpClient.close()
        self.sshClient.close()
        self.virtualMachine.poweroff()
        time.sleep(1) # virtualbox needs time to make changes to the .vbox file, alternative: just restore from the .vbox-prev without waiting
        self.virtualMachine.restoreCurrent()
        time.sleep(1) # virtualbox needs time to make changes to the .vbox file

class VirtualMachine:
    def __init__(self, config):
        self.name = '"' + config["vmName"] + '"'

    def startvm(self):
        p = Popen('vboxmanage startvm ' + self.name, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
        for line in p.stdout:
            line = line.rstrip()
            logger.info(line)

    def poweroff(self):
        p = Popen('vboxmanage controlvm ' + self.name + ' poweroff', shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
        for line in p.stdout:
            line = line.rstrip()
            logger.info(line)

    def restore(self, snapshotName): # snapshotName can be also an UUID
        snapshotName = '"' + snapshotName + '"'
        p = Popen('vboxmanage snapshot ' + self.name + ' restore ' + snapshotName, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
        for line in p.stdout:
            line = line.rstrip()
            logger.info(line)

    def restoreCurrent(self):
        p = Popen('vboxmanage snapshot ' + self.name + ' restorecurrent', shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
        for line in p.stdout:
            line = line.rstrip()
            logger.info(line)


class SSHClient:
    def __init__(self, config):
        self.host = config["host"]
        self.port = config["port"]
        self.user = config["user"]
        self.password = config["password"]
        self.keyPath = config["keyPath"]
        self.runExecFromDir = config["runExecFromDir"]

    def establishConnection(self):
        client = paramiko.SSHClient()
        client.load_system_host_keys()
        client.connect(self.host, port=self.port, username=self.user, key_filename=self.keyPath)
        self.client = client

    def execute(self, cmdStr):
        stdin, stdout, stderr = self.client.exec_command(cmdStr)

        logger.info("[+] Execute: " + cmdStr)
        logger.info("[-]--------------------------------------------------------------stdout:")

        stdoutText = ""
        stderrText = ""

        try:
            for line in stdout.readlines():
                stdoutText = stdoutText + line[:-1]
                logger.info(line[:-1])  # skip newline
        except UnicodeDecodeError as e:
            logger.warning("Exception: \n" + traceback.format_exc() + "\nReturn without decoding")
            stdoutText = str(stdout.read())

        logger.info("[-]--------------------------------------------------------------stderr:")
        try:
            for line in stderr.readlines():
                stderrText = stderrText + line[:-1]
                logger.info(line[:-1])
        except UnicodeDecodeError as e:
            logger.warning("Exception: \n" + traceback.format_exc() + "\nReturn without decoding")
            stderrText = str(stderr.read())
            logger.info(stderrText)

        logger.info("##############################################################")
        return stdoutText, stderrText

    def close(self):
        self.client.close()


class SFTPClient:
    def __init__(self, sshClient):
        self.sshClient = sshClient

    def establishSFTP(self):
        logger.info("[+] Establish SFTP connection ...")
        self.sftpClient = self.sshClient.client.open_sftp()

    def close(self):
        self.sftpClient.close()

    def uploadFile(self, localFilePath, remoteFilePath):
        logger.info("[+] UploadFile - localFilePath: " + localFilePath + " | remoteFilePath: " + remoteFilePath)
        self.sftpClient.put(localFilePath, remoteFilePath)

    def downloadFile(self, remoteFilePath, localFilePath):
        logger.info("[+] DownloadFile - remoteFilePath: " + remoteFilePath + " | localFilePath: " + localFilePath)
        self.sftpClient.get(remoteFilePath, localFilePath)

    def downloadDir(self, remoteDirPath, localDirPath): # dirPath's must end with /
        logger.info("[+] DownloadDir - remoteDirPath: " + remoteDirPath + " | localDirPath: " + localDirPath)

        if not os.path.exists(localDirPath):
            os.makedirs(localDirPath)

        filenames = self.sftpClient.listdir(remoteDirPath)

        for filename in filenames:
            if  self.isDir(remoteDirPath + filename):
                self.downloadDir(remoteDirPath + filename + "/", localDirPath + filename + "/")
            else:
                self.downloadFile(remoteDirPath + filename, localDirPath + filename)

    def isDir(self, path):
        try:
            return S_ISDIR(self.sftpClient.stat(path).st_mode)
        except IOError:
            return False

